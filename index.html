<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Black Box Buddy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #060811 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .logo {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .tagline {
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 30px;
        }

        .main-card {
            background: white;
            border-radius: 5px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 40px;
            margin-bottom: 30px;
        }

        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .upload-box {
            border: 3px solid #4e5ea6;
            border-radius: 5px;
            padding: 40px 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upload-box:hover {
            border-color: #764ba2;
            background: linear-gradient(135deg, #667eea10, #764ba210);
            transform: translateY(-2px);
        }

        .upload-box.dragover {
            border-color: #4CAF50;
            background: #4CAF5010;
        }

        .upload-box.file-loaded {
            border-color: #4CAF50;
            background: #4CAF5015;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #667eea;
        }

        .upload-text {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 15px;
        }

        .file-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .file-info {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            font-size: 0.9em;
            color: #666;
        }

        .settings-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .settings-title {
            font-size: 1.3em;
            margin-bottom: 20px;
            color: #333;
            font-weight: 600;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 20px;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
        }

        .setting-label {
            font-weight: 500;
            margin-bottom: 8px;
            color: #555;
        }

        .setting-input {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .setting-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .weight-info {
            font-size: 0.8em;
            color: #888;
            margin-top: 4px;
        }

        .action-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .btn {
            padding: 15px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #2d3765, #764ba2);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .progress-section {
            display: none;
            margin-bottom: 30px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            color: #666;
            font-weight: 500;
        }

        .results-section {
            display: none;
        }

        .results-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .results-title {
            font-size: 1.5em;
            color: #333;
            font-weight: 600;
        }

        .download-btn {
            background: #28a745;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .download-btn:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .matches-preview {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .match-item {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 15px;
            padding: 15px;
            border-bottom: 1px solid #eee;
            align-items: center;
        }

        .match-item:last-child {
            border-bottom: none;
        }

        .match-source, .match-target {
            display: flex;
            flex-direction: column;
        }

        .match-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .match-artist {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 3px;
        }

        .match-writer {
            color: #888;
            font-size: 0.85em;
            font-style: italic;
        }

        .match-score {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #f5c6cb;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #c3e6cb;
        }

        .footer {
            text-align: center;
            color: white;
            margin-top: 40px;
            opacity: 0.8;
        }

        @media (max-width: 768px) {
            .upload-section {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">Black Box</div>
            <div class="tagline">Match Your Works, Claim Your Rights</div>
        </div>

        <div class="main-card">
            <div class="upload-section">
                <div class="upload-box" id="internalUpload">
                    <div class="upload-icon">📊</div>
                    <div class="upload-text">Upload Internal Catalog</div>
                    <div style="font-size: 0.9em; color: #999;">Drop Excel/CSV file here or click to browse</div>
                    <input type="file" class="file-input" id="internalFile" accept=".xlsx,.xls,.csv">
                    <div class="file-info" id="internalInfo" style="display: none;"></div>
                </div>

                <div class="upload-box" id="blackboxUpload">
                    <div class="upload-icon">🔍</div>
                    <div class="upload-text">Upload Black Box Data</div>
                    <div style="font-size: 0.9em; color: #999;">Drop Excel/CSV file here or click to browse</div>
                    <input type="file" class="file-input" id="blackboxFile" accept=".xlsx,.xls,.csv">
                    <div class="file-info" id="blackboxInfo" style="display: none;"></div>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">⚙️ Matching Settings</div>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label class="setting-label">Match Threshold (%)</label>
                        <input type="number" class="setting-input" id="threshold" value="50" min="0" max="100">
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">Close Match Threshold (%)</label>
                        <input type="number" class="setting-input" id="closeThreshold" value="40" min="0" max="100">
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">Title Weight</label>
                        <input type="number" class="setting-input" id="titleWeight" value="0.4" min="0" max="1" step="0.1">
                        <div class="weight-info">Importance of song title matching</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">Artist Weight</label>
                        <input type="number" class="setting-input" id="artistWeight" value="0.35" min="0" max="1" step="0.1">
                        <div class="weight-info">Importance of artist matching</div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">Writer Weight</label>
                        <input type="number" class="setting-input" id="writerWeight" value="0.25" min="0" max="1" step="0.1">
                        <div class="weight-info">Importance of writer/songwriter matching</div>
                    </div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" id="startMatching" disabled>
                    🚀 Start Matching
                </button>
                <button class="btn btn-secondary" id="clearFiles">
                    🗑️ Clear Files
                </button>
            </div>

            <div class="progress-section" id="progressSection">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText">Initializing...</div>
            </div>

            <div id="errorMessage" class="error-message" style="display: none;"></div>
            <div id="successMessage" class="success-message" style="display: none;"></div>
        </div>

        <div class="results-section" id="resultsSection">
            <div class="results-card">
                <div class="results-header">
                    <div class="results-title">📈 Matching Results</div>
                    <button class="download-btn" id="downloadBtn">
                        ⬇️ Download CSV
                    </button>
                </div>

                <div class="stats-grid" id="statsGrid">
                    <div class="stat-card">
                        <div class="stat-number" id="totalMatches">0</div>
                        <div class="stat-label">Total Matches</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="highConfidence">0</div>
                        <div class="stat-label">High Confidence</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="mediumConfidence">0</div>
                        <div class="stat-label">Medium Confidence</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="averageScore">0%</div>
                        <div class="stat-label">Average Score</div>
                    </div>
                </div>

                <div class="matches-preview" id="matchesPreview"></div>
            </div>
        </div>

        <div class="footer">
            <p>© 2025 Black Box</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        class FuzzyMatcher {
            constructor() {
                this.internalData = null;
                this.blackboxData = null;
                this.matches = [];
                this.scoreCache = new Map();
                this.fieldCache = new Map()
                this.settings = {
                    threshold: 50,
                    closeThreshold: 40,
                    titleWeight: 0.4,
                    artistWeight: 0.35,
                    writerWeight: 0.25
                };
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                // File upload handlers
                document.getElementById('internalFile').addEventListener('change', (e) => {
                    this.handleFileUpload(e, 'internal');
                });

                document.getElementById('blackboxFile').addEventListener('change', (e) => {
                    this.handleFileUpload(e, 'blackbox');
                });

                // Drag and drop handlers
                this.setupDragAndDrop('internalUpload', 'internal');
                this.setupDragAndDrop('blackboxUpload', 'blackbox');

                // Button handlers
                document.getElementById('startMatching').addEventListener('click', () => {
                    this.startMatching();
                });

                document.getElementById('clearFiles').addEventListener('click', () => {
                    this.clearFiles();
                });

                document.getElementById('downloadBtn').addEventListener('click', () => {
                    this.downloadResults();
                });

                // Settings change handlers
                ['threshold', 'closeThreshold', 'titleWeight', 'artistWeight', 'writerWeight'].forEach(id => {
                    document.getElementById(id).addEventListener('change', (e) => {
                        this.settings[id] = parseFloat(e.target.value);
                        this.validateWeights();
                    });
                });
            }

            // Add these methods to the FuzzyMatcher class

preprocessData(data, type) {
    return data.map((record, index) => {
        const titleFields = ['title', 'Title', 'reported title', 'Reported Title', 'song', 'Song', 'track', 'Track'];
        const artistFields = ['artist', 'Artist', 'reported artist', 'Reported Artist', 'performer', 'Performer'];
        const writerFields = ['writer', 'Writer', 'writers', 'Writers', 'songwriter', 'Songwriter', 'composer', 'Composer', 'author', 'Author'];
        
        const title = this.getFieldValue(record, titleFields);
        const artist = this.getFieldValue(record, artistFields);
        const writer = this.getFieldValue(record, writerFields);
        
        return {
            id: `${type}_${index}`,
            original: record,
            title: {
                raw: title,
                clean: this.cleanText(title),
                tokens: this.tokenize(title),
                firstChar: title.charAt(0).toLowerCase()
            },
            artist: {
                raw: artist,
                clean: this.cleanText(artist),
                tokens: this.tokenize(artist),
                firstChar: artist.charAt(0).toLowerCase()
            },
            writer: {
                raw: writer,
                clean: this.cleanText(writer),
                tokens: this.tokenize(writer),
                firstChar: writer.charAt(0).toLowerCase()
            }
        };
    });
}

tokenize(text) {
    if (!text) return [];
    return this.cleanText(text).split(' ').filter(token => token.length > 1);
}

buildIndex(preprocessedData) {
    const index = {
        byFirstChar: {},
        byTokens: {},
        byLength: {}
    };
    
    preprocessedData.forEach(record => {
        // Index by first character
        ['title', 'artist', 'writer'].forEach(field => {
            const firstChar = record[field].firstChar;
            if (firstChar && firstChar !== '') {
                if (!index.byFirstChar[firstChar]) index.byFirstChar[firstChar] = [];
                index.byFirstChar[firstChar].push(record);
            }
        });
        
        // Index by tokens (words)
        ['title', 'artist', 'writer'].forEach(field => {
            record[field].tokens.forEach(token => {
                if (!index.byTokens[token]) index.byTokens[token] = [];
                index.byTokens[token].push(record);
            });
        });
        
        // Index by length ranges
        ['title', 'artist', 'writer'].forEach(field => {
            const length = Math.floor(record[field].clean.length / 5) * 5; // Group by 5-char ranges
            if (!index.byLength[length]) index.byLength[length] = [];
            index.byLength[length].push(record);
        });
    });
    
    return index;
}

getCandidates(blackboxRecord, internalIndex) {
    const candidates = new Set();
    
    // Get candidates by first character match
    ['title', 'artist', 'writer'].forEach(field => {
        const firstChar = blackboxRecord[field].firstChar;
        if (firstChar && internalIndex.byFirstChar[firstChar]) {
            internalIndex.byFirstChar[firstChar].forEach(record => candidates.add(record));
        }
    });
    
    // Get candidates by shared tokens
    ['title', 'artist', 'writer'].forEach(field => {
        blackboxRecord[field].tokens.forEach(token => {
            if (internalIndex.byTokens[token]) {
                internalIndex.byTokens[token].forEach(record => candidates.add(record));
            }
        });
    });
    
    // Get candidates by similar length
    ['title', 'artist', 'writer'].forEach(field => {
        const length = Math.floor(blackboxRecord[field].clean.length / 5) * 5;
        const ranges = [length - 5, length, length + 5];
        ranges.forEach(range => {
            if (internalIndex.byLength[range]) {
                internalIndex.byLength[range].forEach(record => candidates.add(record));
            }
        });
    });
    
    return Array.from(candidates);
}

            validateWeights() {
                const totalWeight = this.settings.titleWeight + this.settings.artistWeight + this.settings.writerWeight;
                if (Math.abs(totalWeight - 1.0) > 0.01) {
                    console.warn(`Warning: Total weights sum to ${totalWeight.toFixed(2)}, consider adjusting for optimal results`);
                }
            }

            setupDragAndDrop(uploadBoxId, type) {
                const uploadBox = document.getElementById(uploadBoxId);
                const fileInput = document.getElementById(type + 'File');

                // Prevent default drag behaviors
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadBox.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });

                // Highlight drop area when item is dragged over it
                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadBox.addEventListener(eventName, () => {
                        uploadBox.classList.add('dragover');
                    });
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    uploadBox.addEventListener(eventName, () => {
                        uploadBox.classList.remove('dragover');
                    });
                });

                // Handle dropped files
                uploadBox.addEventListener('drop', (e) => {
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.processFile(files[0], type);
                    }
                });

                // Handle click to browse
                uploadBox.addEventListener('click', (e) => {
                    // Don't trigger if clicking on the file input itself
                    if (e.target !== fileInput) {
                        fileInput.click();
                    }
                });
            }

            async handleFileUpload(event, type) {
                const file = event.target.files[0];
                if (!file) return;

                await this.processFile(file, type);
            }

            async processFile(file, type) {
                const fileInfo = document.getElementById(type + 'Info');
                const uploadBox = document.getElementById(type + 'Upload');
                
                this.hideMessages();

                try {
                    fileInfo.style.display = 'block';
                    fileInfo.innerHTML = `📄 Processing ${file.name} (${this.formatFileSize(file.size)})...`;

                    const data = await this.parseFile(file);
                    
                    if (!data || data.length === 0) {
                        throw new Error('No data found in file');
                    }

                    if (type === 'internal') {
                        this.internalData = data;
                    } else {
                        this.blackboxData = data;
                    }

                    fileInfo.innerHTML = `✅ ${file.name} (${this.formatFileSize(file.size)}) - ${data.length} records loaded`;
                    uploadBox.classList.add('file-loaded');

                    this.updateStartButton();
                    this.showSuccess(`${type === 'internal' ? 'Internal Catalog' : 'Black Box Data'} loaded successfully: ${data.length} records`);

                } catch (error) {
                    console.error('File processing error:', error);
                    fileInfo.innerHTML = `❌ Error loading ${file.name}`;
                    uploadBox.classList.remove('file-loaded');
                    this.showError(`Error loading ${type} file: ${error.message}`);
                }
            }

            async parseFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        try {
                            let data;
                            
                            if (file.name.toLowerCase().endsWith('.csv')) {
                                data = this.parseCSV(e.target.result);
                            } else if (file.name.toLowerCase().match(/\.(xlsx|xls)$/)) {
                                const workbook = XLSX.read(e.target.result, {type: 'array'});
                                const sheetName = workbook.SheetNames[0];
                                const worksheet = workbook.Sheets[sheetName];
                                data = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                                data = this.convertArrayToObjects(data);
                            } else {
                                throw new Error('Unsupported file format. Please upload CSV or Excel files.');
                            }
                            
                            resolve(data);
                        } catch (error) {
                            console.error('Parse error:', error);
                            reject(error);
                        }
                    };
                    
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    
                    if (file.name.toLowerCase().endsWith('.csv')) {
                        reader.readAsText(file);
                    } else {
                        reader.readAsArrayBuffer(file);
                    }
                });
            }

            parseCSV(text) {
                const lines = text.split('\n').filter(line => line.trim());
                if (lines.length === 0) return [];
                
                const headers = this.parseCSVLine(lines[0]);
                const data = [];
                
                for (let i = 1; i < lines.length; i++) {
                    const values = this.parseCSVLine(lines[i]);
                    if (values.length > 0) {
                        const row = {};
                        headers.forEach((header, index) => {
                            row[header] = values[index] || '';
                        });
                        data.push(row);
                    }
                }
                
                return data;
            }

            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                result.push(current.trim());
                return result;
            }

            convertArrayToObjects(arrayData) {
                if (arrayData.length === 0) return [];
                
                const headers = arrayData[0].map(h => h ? h.toString().trim() : '');
                const data = [];
                
                for (let i = 1; i < arrayData.length; i++) {
                    const row = {};
                    let hasData = false;
                    
                    headers.forEach((header, index) => {
                        const value = arrayData[i][index] ? arrayData[i][index].toString().trim() : '';
                        row[header] = value;
                        if (value) hasData = true;
                    });
                    
                    if (hasData) {
                        data.push(row);
                    }
                }
                
                return data;
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            updateStartButton() {
                const startBtn = document.getElementById('startMatching');
                startBtn.disabled = !this.internalData || !this.blackboxData;
            }

            clearFiles() {
                this.internalData = null;
                this.blackboxData = null;
                this.matches = [];
                this.clearCache();
                this.fieldCache = new Map();
                
                // Reset file inputs
                document.getElementById('internalFile').value = '';
                document.getElementById('blackboxFile').value = '';
                
                // Hide file info
                document.getElementById('internalInfo').style.display = 'none';
                document.getElementById('blackboxInfo').style.display = 'none';
                
                // Remove visual indicators
                document.getElementById('internalUpload').classList.remove('file-loaded');
                document.getElementById('blackboxUpload').classList.remove('file-loaded');
                
                // Hide results
                document.getElementById('resultsSection').style.display = 'none';
                
                this.updateStartButton();
                this.hideMessages();
            }

            getCachedScore(str1, str2, type) {
    const key = `${type}:${str1}:${str2}`;
    if (this.scoreCache.has(key)) {
        return this.scoreCache.get(key);
    }
    
    const score = this.fastFuzzyMatch(str1, str2);
    
    // Only cache if we have space (prevent memory bloat)
    if (this.scoreCache.size < 10000) {
        this.scoreCache.set(key, score);
    }
    
    return score;
}

clearCache() {
    this.scoreCache.clear();
}

            async startMatching() {
                this.showProgress();
                this.hideMessages();
                
                try {
                    await this.performMatching();
                    this.showResults();
                } catch (error) {
                    console.error('Matching error:', error);
                    this.showError(`Matching failed: ${error.message}`);
                } finally {
                    this.hideProgress();
                }
            }

            async performMatching() {
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    
    // Preprocessing phase
    progressText.textContent = 'Preprocessing data...';
    progressFill.style.width = '5%';
    
    const preprocessedBlackbox = this.preprocessData(this.blackboxData, 'blackbox');
    const preprocessedInternal = this.preprocessData(this.internalData, 'internal');
    
    progressText.textContent = 'Building search index...';
    progressFill.style.width = '10%';
    
    const internalIndex = this.buildIndex(preprocessedInternal);
    
    // Matching phase
    const matches = [];
    const totalComparisons = preprocessedBlackbox.length;
    
    for (let i = 0; i < preprocessedBlackbox.length; i++) {
        const blackboxRecord = preprocessedBlackbox[i];
        
        // Get candidates using indexing (dramatically reduces comparisons)
        const candidates = this.getCandidates(blackboxRecord, internalIndex);
        
        let bestMatch = null;
        let bestScore = 0;
        
        // Only compare against candidates, not entire dataset
        for (const candidate of candidates) {
            const score = this.calculateOptimizedMatchScore(blackboxRecord, candidate);
            
            // Early termination for very high scores
            if (score > 95) {
                bestMatch = candidate;
                bestScore = score;
                break;
            }
            
            if (score > bestScore) {
                bestScore = score;
                bestMatch = candidate;
            }
        }
        
        if (bestScore >= this.settings.threshold) {
            matches.push({
                blackboxRecord: blackboxRecord.original,
                internalRecord: bestMatch.original,
                score: bestScore,
                confidence: bestScore >= 80 ? 'high' : 'medium'
            });
        }
        
        // Update progress
        const progress = ((i + 1) / totalComparisons) * 85 + 15;
        progressFill.style.width = `${progress}%`;
        progressText.textContent = `Matching records: ${i + 1}/${totalComparisons} (${candidates.length} candidates)`;
        
        // Allow UI to update less frequently
        if (i % 50 === 0) {
            await new Promise(resolve => setTimeout(resolve, 1));
        }
    }
    
    progressFill.style.width = '100%';
    progressText.textContent = 'Matching complete!';
    
    this.matches = matches;
}

            calculateMatchScore(blackboxRecord, internalRecord) {
                // Get possible field names for title, artist, and writer
                const titleFields = ['title', 'Title', 'reported title', 'Reported Title', 'song', 'Song', 'track', 'Track'];
                const artistFields = ['artist', 'Artist', 'reported artist', 'Reported Artist', 'performer', 'Performer'];
                const writerFields = ['writer', 'Writer', 'writers', 'Writers', 'songwriter', 'Songwriter', 'composer', 'Composer', 'author', 'Author'];
                
                const bbTitle = this.getFieldValue(blackboxRecord, titleFields);
                const bbArtist = this.getFieldValue(blackboxRecord, artistFields);
                const bbWriter = this.getFieldValue(blackboxRecord, writerFields);
                
                const intTitle = this.getFieldValue(internalRecord, titleFields);
                const intArtist = this.getFieldValue(internalRecord, artistFields);
                const intWriter = this.getFieldValue(internalRecord, writerFields);
                
                const titleScore = this.fuzzyMatch(bbTitle, intTitle);
                const artistScore = this.fuzzyMatch(bbArtist, intArtist);
                const writerScore = this.fuzzyMatch(bbWriter, intWriter);
                
                // Calculate weighted score
                const totalScore = (titleScore * this.settings.titleWeight) + 
                                 (artistScore * this.settings.artistWeight) + 
                                 (writerScore * this.settings.writerWeight);
                
                return Math.min(100, totalScore);
            }

            calculateOptimizedMatchScore(blackboxRecord, internalRecord) {
    // Use pre-processed clean text to avoid repeated cleaning
    const titleScore = this.fastFuzzyMatch(
        blackboxRecord.title.clean, 
        internalRecord.title.clean,
        blackboxRecord.title.tokens,
        internalRecord.title.tokens
    );
    
    const artistScore = this.fastFuzzyMatch(
        blackboxRecord.artist.clean, 
        internalRecord.artist.clean,
        blackboxRecord.artist.tokens,
        internalRecord.artist.tokens
    );
    
    const writerScore = this.fastFuzzyMatch(
        blackboxRecord.writer.clean, 
        internalRecord.writer.clean,
        blackboxRecord.writer.tokens,
        internalRecord.writer.tokens
    );
    
    // Calculate weighted score
    const totalScore = (titleScore * this.settings.titleWeight) + 
                      (artistScore * this.settings.artistWeight) + 
                      (writerScore * this.settings.writerWeight);
    
    return Math.min(100, totalScore);
}

            getFieldValue(record, possibleFields) {
    // Create a cache key for this record
    const recordKey = JSON.stringify(record);
    const fieldsKey = possibleFields.join(',');
    const cacheKey = `${recordKey}:${fieldsKey}`;
    
    // Check cache first
    if (this.fieldCache && this.fieldCache.has(cacheKey)) {
        return this.fieldCache.get(cacheKey);
    }
    
    // Find the field value
    let value = '';
    for (const field of possibleFields) {
        if (record[field]) {
            value = record[field];
            break;
        }
    }
    
    const cleanValue = this.cleanText(value);
    
    // Cache the result
    if (!this.fieldCache) this.fieldCache = new Map();
    if (this.fieldCache.size < 5000) {
        this.fieldCache.set(cacheKey, cleanValue);
    }
    
    return cleanValue;
}

            cleanText(text) {
                if (!text) return '';
                return text.toString()
                    .toLowerCase()
                    .replace(/[^\w\s]/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
            }

            fastFuzzyMatch(str1, str2, tokens1 = null, tokens2 = null) {
    if (!str1 || !str2) return 0;
    if (str1 === str2) return 100;
    
    // Quick length-based filter
    const lengthDiff = Math.abs(str1.length - str2.length);
    const maxLength = Math.max(str1.length, str2.length);
    if (lengthDiff > maxLength * 0.7) return 0; // Too different in length
    
    // Use Jaro-Winkler similarity (faster than Levenshtein)
    const jaroScore = this.jaroWinkler(str1, str2);
    
    // Token-based similarity for additional accuracy
    const tokenScore = this.tokenSimilarity(tokens1 || str1.split(' '), tokens2 || str2.split(' '));
    
    // Combine scores (weighted toward character-level similarity)
    return Math.max(jaroScore * 0.7 + tokenScore * 0.3, jaroScore, tokenScore);
}

jaroWinkler(s1, s2) {
    if (s1 === s2) return 100;
    
    const len1 = s1.length;
    const len2 = s2.length;
    
    if (len1 === 0 || len2 === 0) return 0;
    
    const matchWindow = Math.floor(Math.max(len1, len2) / 2) - 1;
    const s1Matches = new Array(len1).fill(false);
    const s2Matches = new Array(len2).fill(false);
    
    let matches = 0;
    let transpositions = 0;
    
    // Find matches
    for (let i = 0; i < len1; i++) {
        const start = Math.max(0, i - matchWindow);
        const end = Math.min(i + matchWindow + 1, len2);
        
        for (let j = start; j < end; j++) {
            if (s2Matches[j] || s1[i] !== s2[j]) continue;
            s1Matches[i] = true;
            s2Matches[j] = true;
            matches++;
            break;
        }
    }
    
    if (matches === 0) return 0;
    
    // Count transpositions
    let k = 0;
    for (let i = 0; i < len1; i++) {
        if (!s1Matches[i]) continue;
        while (!s2Matches[k]) k++;
        if (s1[i] !== s2[k]) transpositions++;
        k++;
    }
    
    const jaro = (matches / len1 + matches / len2 + (matches - transpositions / 2) / matches) / 3;
    
    // Winkler modification
    let prefix = 0;
    for (let i = 0; i < Math.min(len1, len2, 4); i++) {
        if (s1[i] === s2[i]) prefix++;
        else break;
    }
    
    return (jaro + 0.1 * prefix * (1 - jaro)) * 100;
}

tokenSimilarity(tokens1, tokens2) {
    if (!tokens1.length || !tokens2.length) return 0;
    
    const set1 = new Set(tokens1);
    const set2 = new Set(tokens2);
    
    const intersection = new Set([...set1].filter(token => set2.has(token)));
    const union = new Set([...set1, ...set2]);
    
    return (intersection.size / union.size) * 100;
}

            levenshteinDistance(str1, str2) {
                const matrix = [];
                
                // Create matrix
                for (let i = 0; i <= str2.length; i++) {
                    matrix[i] = [i];
                }
                
                for (let j = 0; j <= str1.length; j++) {
                    matrix[0][j] = j;
                }
                
                // Fill matrix
                for (let i = 1; i <= str2.length; i++) {
                    for (let j = 1; j <= str1.length; j++) {
                        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }
                
                return matrix[str2.length][str1.length];
            }

            calculateWordMatches(str1, str2) {
                const words1 = str1.split(' ').filter(w => w.length > 0);
                const words2 = str2.split(' ').filter(w => w.length > 0);
                
                if (words1.length === 0 || words2.length === 0) return 0;
                
                let matches = 0;
                const used = new Set();
                
                for (const word1 of words1) {
                    for (let i = 0; i < words2.length; i++) {
                        if (used.has(i)) continue;
                        
                        const word2 = words2[i];
                        const wordSimilarity = this.wordSimilarity(word1, word2);
                        
                        if (wordSimilarity > 0.8) {
                            matches++;
                            used.add(i);
                            break;
                        }
                    }
                }
                
                const totalWords = Math.max(words1.length, words2.length);
                return (matches / totalWords) * 100;
            }

            wordSimilarity(word1, word2) {
                if (word1 === word2) return 1;
                
                const distance = this.levenshteinDistance(word1, word2);
                const maxLength = Math.max(word1.length, word2.length);
                
                return (maxLength - distance) / maxLength;
            }

            showResults() {
                const resultsSection = document.getElementById('resultsSection');
                const statsGrid = document.getElementById('statsGrid');
                
                // Calculate statistics
                const totalMatches = this.matches.length;
                const highConfidence = this.matches.filter(m => m.confidence === 'high').length;
                const mediumConfidence = this.matches.filter(m => m.confidence === 'medium').length;
                const averageScore = totalMatches > 0 ? 
                    Math.round(this.matches.reduce((sum, m) => sum + m.score, 0) / totalMatches) : 0;
                
                // Update statistics
                document.getElementById('totalMatches').textContent = totalMatches;
                document.getElementById('highConfidence').textContent = highConfidence;
                document.getElementById('mediumConfidence').textContent = mediumConfidence;
                document.getElementById('averageScore').textContent = averageScore + '%';
                
                // Show preview of matches
                this.showMatchesPreview();
                
                // Show results section
                resultsSection.style.display = 'block';
                
                // Scroll to results
                resultsSection.scrollIntoView({ behavior: 'smooth' });
                
                this.showSuccess(`Matching complete! Found ${totalMatches} matches with average score of ${averageScore}%`);
            }

            showMatchesPreview() {
                const preview = document.getElementById('matchesPreview');
                preview.innerHTML = '';
                
                if (this.matches.length === 0) {
                    preview.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No matches found above the threshold</div>';
                    return;
                }
                
                // Sort matches by score (highest first)
                const sortedMatches = this.matches.sort((a, b) => b.score - a.score);
                
                // Show top 50 matches in preview
                const previewMatches = sortedMatches.slice(0, 50);
                
                previewMatches.forEach((match, index) => {
                    const matchElement = document.createElement('div');
                    matchElement.className = 'match-item';
                    
                    const titleFields = ['title', 'Title', 'reported title', 'Reported Title', 'song', 'Song', 'track', 'Track'];
                    const artistFields = ['artist', 'Artist', 'reported artist', 'Reported Artist', 'performer', 'Performer'];
                    const writerFields = ['writer', 'Writer', 'writers', 'Writers', 'songwriter', 'Songwriter', 'composer', 'Composer', 'author', 'Author'];
                    
                    const bbTitle = this.getFieldValue(match.blackboxRecord, titleFields) || 'N/A';
                    const bbArtist = this.getFieldValue(match.blackboxRecord, artistFields) || 'N/A';
                    const bbWriter = this.getFieldValue(match.blackboxRecord, writerFields) || 'N/A';
                    
                    const intTitle = this.getFieldValue(match.internalRecord, titleFields) || 'N/A';
                    const intArtist = this.getFieldValue(match.internalRecord, artistFields) || 'N/A';
                    const intWriter = this.getFieldValue(match.internalRecord, writerFields) || 'N/A';
                    
                    matchElement.innerHTML = `
                        <div class="match-source">
                            <div class="match-title">${this.escapeHtml(bbTitle)}</div>
                            <div class="match-artist">${this.escapeHtml(bbArtist)}</div>
                            <div class="match-writer">${this.escapeHtml(bbWriter)}</div>
                        </div>
                        <div class="match-target">
                            <div class="match-title">${this.escapeHtml(intTitle)}</div>
                            <div class="match-artist">${this.escapeHtml(intArtist)}</div>
                            <div class="match-writer">${this.escapeHtml(intWriter)}</div>
                        </div>
                        <div class="match-score">${Math.round(match.score)}%</div>
                    `;
                    
                    preview.appendChild(matchElement);
                });
                
                if (this.matches.length > 50) {
                    const moreElement = document.createElement('div');
                    moreElement.style.textAlign = 'center';
                    moreElement.style.padding = '20px';
                    moreElement.style.color = '#666';
                    moreElement.style.fontStyle = 'italic';
                    moreElement.textContent = `... and ${this.matches.length - 50} more matches. Download CSV for complete results.`;
                    preview.appendChild(moreElement);
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            downloadResults() {
                if (this.matches.length === 0) {
                    this.showError('No matches to download');
                    return;
                }
                
                // Create CSV content
                const headers = this.createCSVHeaders();
                const csvContent = [headers].concat(
                    this.matches.map(match => this.createCSVRow(match))
                ).join('\n');
                
                // Create and trigger download
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                
                if (link.download !== undefined) {
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', `fuzzy_matches_${new Date().toISOString().split('T')[0]}.csv`);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                    this.showSuccess('Results downloaded successfully!');
                } else {
                    this.showError('Download not supported in this browser');
                }
            }

            createCSVHeaders() {
                const headers = [
                    'Match Score',
                    'Confidence',
                    'BB Title',
                    'BB Artist', 
                    'BB Writer',
                    'Internal Title',
                    'Internal Artist',
                    'Internal Writer'
                ];
                
                // Add any additional fields from the data
                if (this.matches.length > 0) {
                    const bbFields = Object.keys(this.matches[0].blackboxRecord);
                    const intFields = Object.keys(this.matches[0].internalRecord);
                    
                    bbFields.forEach(field => {
                        if (!headers.includes('BB ' + field)) {
                            headers.push('BB ' + field);
                        }
                    });
                    
                    intFields.forEach(field => {
                        if (!headers.includes('Internal ' + field)) {
                            headers.push('Internal ' + field);
                        }
                    });
                }
                
                return headers.map(h => `"${h}"`).join(',');
            }

            createCSVRow(match) {
                const titleFields = ['title', 'Title', 'reported title', 'Reported Title', 'song', 'Song', 'track', 'Track'];
                const artistFields = ['artist', 'Artist', 'reported artist', 'Reported Artist', 'performer', 'Performer'];
                const writerFields = ['writer', 'Writer', 'writers', 'Writers', 'songwriter', 'Songwriter', 'composer', 'Composer', 'author', 'Author'];
                
                const row = [
                    Math.round(match.score),
                    match.confidence,
                    this.getFieldValue(match.blackboxRecord, titleFields) || '',
                    this.getFieldValue(match.blackboxRecord, artistFields) || '',
                    this.getFieldValue(match.blackboxRecord, writerFields) || '',
                    this.getFieldValue(match.internalRecord, titleFields) || '',
                    this.getFieldValue(match.internalRecord, artistFields) || '',
                    this.getFieldValue(match.internalRecord, writerFields) || ''
                ];
                
                // Add additional fields
                Object.keys(match.blackboxRecord).forEach(field => {
                    row.push(match.blackboxRecord[field] || '');
                });
                
                Object.keys(match.internalRecord).forEach(field => {
                    row.push(match.internalRecord[field] || '');
                });
                
                return row.map(cell => `"${this.escapeCSV(cell)}"`).join(',');
            }

            escapeCSV(text) {
                if (!text) return '';
                return text.toString().replace(/"/g, '""');
            }

            showProgress() {
                document.getElementById('progressSection').style.display = 'block';
                document.getElementById('progressFill').style.width = '0%';
            }

            hideProgress() {
                document.getElementById('progressSection').style.display = 'none';
            }

            showError(message) {
                const errorElement = document.getElementById('errorMessage');
                errorElement.textContent = message;
                errorElement.style.display = 'block';
                
                setTimeout(() => {
                    errorElement.style.display = 'none';
                }, 5000);
            }

            showSuccess(message) {
                const successElement = document.getElementById('successMessage');
                successElement.textContent = message;
                successElement.style.display = 'block';
                
                setTimeout(() => {
                    successElement.style.display = 'none';
                }, 5000);
            }

            hideMessages() {
                document.getElementById('errorMessage').style.display = 'none';
                document.getElementById('successMessage').style.display = 'none';
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new FuzzyMatcher();
        });
    </script>
</body>
</html>